C语言是一门结构化的程序设计语言：

     .c文件(源文件)到.exe文件(可执行文件)需要：编译——>链接——>运行  的过程
1、顺序结构
2、选择结构
3、循环结构

一、语句
由;隔开的句子是一条语句  
而 只有；的句子是空语句
1、分支语句

  <1>、if语句
 
     语法结构：
        //单分支：
           if(表达式1）
                    语句;
        //双分支：
            if（表达式2）
                    语句1;
            else
                    语句2;
        //多分支
            if(表达式1）
                     语句1；
            else if
注意： else和距离他最近的if进行匹配                      还有while的应用（循环）

      <2>、switch语句（switch case语句）

      case决定入口，break决定出口；
注意：switch函数的类型是整型， 而default是处理非法的输入指令

default 与case  没有顺序可言，       case与default后面都是：
好习惯：每个switch语句中都加入default子语句和break
 
2、循环语句
· while
· for
· do while

     <1>while循环
               //while 语法结构
          while(表达式)
                   循环语句：                                 //如果条件为真，那么将会一直循环直到遇见假的条件，才停止循环

注：stmt是语句的意思

注：break是结束当前语句，而continue是继续该语句，是直接进行该语句，不向该语句continue以下的代码继续（终止本次循环中continue之后的代码）
     或者这样说：a.在循环中只要遇到break，就会停止后期的所有循环，直接终止循环。所以：while循环中break是用于永久终止循环的
                         b.continue是用于终止本次循环的，也就是本次循环中continue后面的代码不会再执行，而是直接跳转到while语句的判断部分。进行下一次循环的入口循环





***getchar是接受字符的，相对应的putchar是输出字符的
     当输入ctrl+z的时候getchar将会识别成EOF
注：EOF-----end of file （文件结束标志）


   <2>for循环

  语法：
             for（表达式1;表达式2;表达式3）
循环语句：

         表达式1为初始化部分，用于初始化循环变量的。表达式2为条件判断部分，用于判断循环时候终止。表达式3为调整部分，用于循环条件的调整




对比：            while循环与for循环

#include<stdio.h>
int main()
{
	int i = 0;
	i =1;//初始化
	while(i<=10)//判断条件
	{
		printf("hehe\n");
		i++;//调整条件
	}
//实现相同的功能，使用for循环
	for(i=1 ;i<=10; i++）
		printf("hehe\n");
	return 0;	
}



注意： 1、不可以在for循环体内修改循环变量，防止for循环失去控制。
	 2、for循环的初始化部分、判断条件部分，调整条件部分可以省略，但是判断条件部分一旦被省略，那么for循环的判断条件就是：恒为真，将会进入死循环
	 3、如果不是非常熟练，建议不要随便省略



       <3>do......while循环


语法结构：
	do
		循环语句；
	while(表达式)；






在一行字符中查找数据：


					逐个查找的方法效率太低可以使用折半的方法：
												折半查找算法或者叫二分查找算法


注意   ：   在计算机中数字是从0开始储存的，即字符串的读数是从0开始的

                                                比如：
						 1	2	3	4	5	6	
				      下标为：  0	1	2	3	4	5



注意： ==不能用来比较两个字符串是否相等，比较两个字符串是否相等应该使用库函数---strcmp

strcmp库函数：
            if（strcmp(a,"123456")）    //如果前一个字符串a的数量大于后面的字符串的数量会返回一个大于0的数值，如果前面的字符串a的数量小于后面的字符串时会返回一个小于0的值



sqrt  库函数  用来开平方的数学库函数            需引用头文件math.h
  



时间戳：
	当前计算机的时间-计算机的起始时间（1970.1.1.0：0：0）=（xxxx）秒
	  

随机数的生成方式：
		1、使用时间戳
		2、运用time函数
		3、将time函数放在主函数中
			具体做法：
					1、#include<stdlib.h>
					2、#include<time.h>
						定义rand
					3、srand( ( unsigned int )time( NULL ))



3、goto语句：（尽量少用goto语句，防止出现没有必要的bug）
	C语言中提供了可以滥用的goto语句和标记跳转的标号。
	从理论上goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。
	但是在某些场合下goto语句还是用得到的，最常见的用法就是终止程序在某些深度嵌套的结构的处理过程，例如一次跳出两层或多层循环。
	
	这种情况使用break是达不到目的的。它只能从最内层循环退出到上一层循环。

	shutdown -s -t 60 设置关机程序--60s后关机

	system（） 是来执行系统命令的
	
	strcmp（）比较两个字符串的函数


二、函数：{库函数和自定义函数}


	在cplusplus.com上查找库函数  zh.cppreference.com

a.库函数：

		1、IO函数
		2、字符串操作函数
		3、字符操作函数
		4、内存操作函数
		5、时间/日期函数
		6、数学函数
		7、其他库函数
注意：一个汉字占2个字节

	类型后加*为指针类型，如：char *     ;int *	会返回该字符串的地址			null为\0 也就是字符串终止标志

<1>strcpy()函数
		
		char * strcpy (char * destination , const char * source );//将source中的字符串拷贝到destination中

<2>memset()函数
		void * memset( void * prt , int * value ,size_t num);


void是无返回值的，在自定义函数时，是用void前缀是不需要返回值的



b、函数的嵌套调用和链式访问
	函数和函数之间可以有机的结合

		函数的嵌套调用：（定义两个函数：new_Line()和three_Line() ，将new_Line()函数的内容嵌套到three_Line()中，然后在主函数中调用three_Line() ）

void new_Line()
{
	printf("hehe\n");
}
void three_Line()
{
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		new_Line();
	}
}
int main()
{
	three_Line();
	return 0;
}

  链式访问：把一个函数的返回值作为另一个函数的参数！



函数的定义：是指函数的具体实现，交代函数的功能实现。

函数的声明：1、告诉编译器有一个函数叫什么，参数是什么，返回类型是什么，但是具体是不是存在，无关紧要！

		2、函数的声明一般出现在函数的使用之前。要满足先声明后使用。

		3、函数的声明一般要放到头文件中的。
		当在主函数后面定义函数的时候需要在主函数前进行函数声明！

int Add(int, int);//函数的声明
int main()
{
	int a = 10;
	int b = 20;
	int sum = 0;
	sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
int Add(int x, int y)
{
	int z = x + y;
	return z;
}


   头文件的引用：引用自己写的头文件使用" "   引用库中的头文件用< >

一般将函数的声明放在.h文件中，将函数的实现放到.c文件（含主函数的文件）中，将函数的定义放到.c文件（函数名.c文件）中，


函数的高内聚低耦合：函数体内部实现修改了，尽量不要对外部产生影响，否则：代码不方便维护！

函数在使用时尽量做到谁申请的谁维护谁释放，否则交给外部使用者释放，外部使用着可能不知道或者忘记，就会造成资源泄漏！



  c、函数递归：

		程序调用自身的编程技巧称为递归。递归作为一种算法在程序设计语言中广泛应用。一个过程或者是函数在其定义或说明中直接或间接
		调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来解决，递归策略只需要少量的
		程序就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。

		递归的主要思考方式在于：把大事化小


	递归的两个必要条件：
				1、存在限制条件，当满足这个限制条件的时候，递归便不再继续。
				2、每次递归调用之后越来越来接近这个限制条件。
				

注意：Stack overflow：栈溢出——递归常见错误（当递归死循环的时候就会栈溢出）



补充：栈区、		堆区、		静态区；
	局部变量		动态开辟的内存	全局变量static修饰的变量




注意：数组传参，传过去的不是整个数组而是第一个元素的地址
如：
int main()
{
	int arr[]={1,2,3,4,5,6,7};
	printf("%d\n",arr);
	printf("%d\n",&arr);
	return 0;//两个打印结果相同！
}
但是：
	（1）、sizeof(数组名)————数组名代表整个数组！sizeof(数组名)计算的是整个数组的大小，单位是字节。
	（2）、&(数组名)————数组名代表整个数组！&(数组名)取出的是整个数组的地址；
			但是打印arr的地址的时候在屏幕上呈现的是首个元素的地址，代表着这个数组从这个地址开始：
			int main()
			{
				int arr[]={1,2,3,4,5,6,7};
				printf("%p\n",arr);//打印数组首个元素的地址
				printf("%p\n",arr[0]);//打印数组首个元素的地址
				printf("%p\n",&arr);//打印数组的开始元素地址
				return 0;//首元素————下标为0的元素
			}


三、数组
	
	int arr[20]={0};
	这里的int [20]就是数组arr的类型！

	1、数组的创建和初始化；
	
错误示范：
{
	int count=5;
	char arr[count]; 
}

// [   ]中一定要是常量，不能是变量！

int main()
{
	char arr[] = "abcdef";
	printf("%d\n", sizeof(arr));//7                    //sizeof计算arr所占的空间的大小
	printf("%d\n", strlen(arr));//6                    //strlen计算字符串的大小，——‘\0'之前的字符个数
	return 0;
}


strlen和sizeof没有多少关联！
（1）strlen是求字符串长度的-只能针对字符串长度--strlen是库函数，使用时得引用头文件
（2）sizeof计算变量、数组、类型的大小--单位是字节---sizeof是操作符

[ ]下标引用操作符 也就是数组访问的操作符

int main()
{
	char arr[]="abcdef";
	printf("%c",arr[3]);打印数组arr中下标为3的字符
	return 0;
}

注意：强制转换类型：（ int ）strlen(arr); //将本来没有返回类型的strlen转换为int类型！

2、二维数组

	二维数组在内存中也是连续储存的
二维数组的初始化：
	int arr[2][3]={{0},{0}};//表示有两行三列；其中{0}表示的是行！
	注意：第二个[]；也就是列不能省略！内部的{}可以省去，只要保证初始化的个数正确就行

二维数组的打印：
int main()
{
	int arr[3][4]={{1,2,3,4},{2,3,4,5},{4,5,6,7}};
	for(int i=0;i<3;i++)//确定行
	{
		for(int j=0;j<4;j++)//确定列
		{
			printf("%d",arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}

%p    地址：printf("%p",&arr[i][j]);//打印地址

 
 
 四、操作符
 
	分类：
		算数操作符
		移位操作符
		位操作符
		赋值操作符
		单目操作符
		关系操作符
		逻辑操作符
		条件操作符
		逗号操作符
		下标引用、函数调用和结构成员
		
	1、算术操作符
		+ - * / %
		
	int main()
	{
		int a=6/5;
		printf("%d\n",a);//打印结果是1
		float b=6/5;
		printf("%f\n",b);//打印结果是1.000000
		float c=6.0/5;//6/5.0  6.0/5.0都一样
		//但是这样会出现一个警告：从“double”到“float”截断
		//只需要改变成:float c=6.0f/5;即将6.0强制转变成单精度类型的就可以
		printf("%f\n",c);//打印结果是1.200000
		 
		
		return 0;
	}
	
	
	例如下面的一行代码：
	int main()
	{
		int a = 7 % 3.0;
		printf("%d\n", a);
		return 0;
	}
	编译时会出现一个错误：“%”: 无效，因为右操作数的类型为“double”
	这是因为在使用取模操作时后面的数字必须是int类型的
	 
	 
		（1）除了%操作符之外，其他的几个操作符可以作用与整数和浮点数
		（2）对于/操作符，如果两个操作符都是整数，执行整数除法。而只要是有浮点是执行的除法就是浮点数除法
		（3）%操作符的两个操作符必须是整数，返回的是整除之后的余数
	
	
	2、移位操作符
	
		<< 左移操作符
				左边丢弃，右边补0；
		>> 右移操作符
				1、算术右移：右边丢弃，左边补原符号位
				2、逻辑右移：右边丢弃，左边补0；
				
				
			整数的二进制表示形式其实有三种：
					原码、反码和补码
				
			*对于负数来说：
				原码：直接根据数值写出的二进制序列就是原码；
				反码：原码的符号位不变，其它位按位取反就是反码；
				补码：反码+1就是补码；
			  例如：
				负数在内存中的形式是补码；（整数的原码、反码和补码是相同的）
				-1：
				原码：10000000000000000000000000000001
				反码：11111111111111111111111111111110
				补码：11111111111111111111111111111111
				二进制在运算的时候符号位也参与运算！
		警告：对于移位操作符，不要移动负数位，这个标准未定义的
		
	3、位操作符
		
		&  按（二进制）位与
			例如：1&0 = 0; 
				  0&1 = 0;
				  1&1 = 1;
				  0&0 = 0;
		|  按（二进制）位或
			例如：1|0 = 1;
				  0|1 = 1;
				  0|0 = 0;
				  1|1 = 1;
		^  按（二进制）位异或
			规则：相同为0.相异为1；
			例如：1^1 = 0;
				  1^0 = 1;
				  0^1 = 1;
				  0^0 = 0;
		
		注意：他们的操作数都是整数
		
	
	4、赋值操作符
	
		赋值操作符是一个很棒的操作符，它可以将你之前不满意的变量任意修改！
		赋值操作符可以连续使用的，但是不好：（x=y=a=b=3;）
		
		= 是一个基本的赋值操作符
		符合操作符：
				+=  -= *= /= %= &= |= ^= >>= <<=
				
	
	5、单目操作符
		
		!  			逻辑反操作
		-  			负值
		+  			正值
		&  			取地址
		sizeof  	操作数的类型长度
		~  			对一个数的二进制按位取反
		++  		前置、后置++
		--  		前置、后置--
		*  			间接访问操作符（解引用操作符）
		(类型)      强制转换类型
		
		
		sizeof计算变量的时候可以把()省略。注意只能在计算变量的大小时省略(),在计算类型的大小的时候不能省略();
		例如：
			int a=0;
			printf("%d",sizeof a)
			输出结果依然是4
		
		注意：sizeof括号中放的表达式是不参与运算的！
		
		~a  操作符
				例如:
					int main()
					{
						int a=-1;
						int b=~a;
						printf("%d\n",a);//输出为-1
						printf("%d\n",b);//输出为0
						return 0;
					}
				
				这个例子是：
						-1=10000000000000000000000000000001
						a =11111111111111111111111111111111
						~a=00000000000000000000000000000000=0;（符号位i也进行计算）
						
						
		后置++     (先使用再++)
			例如：
				int main()
				{
					int a=10;
					int b=a++;
					printf("%d\n",a);//输出结果为11
					printf("%d\n",b);//输出结果为10
					return 0;
				}
		
		前置++      (先++再使用)
		
			
		* 解引用操作符
			int main()
			{
				int a=10;
				printf("%d\n",&a);// & -取地址操作符
				int * pa = &a; //pa 是用来存放地址的  - pa就是一个指针变量
				*pa = 20; // * - 解引用操作符 - 间接访问操作符
				printf("%d\n",a);//输出结果为20
				return 0;
			}
			
			
	5、关系操作符
		>  <  >=  <=  
		!=  用于测试“不相等”
		==	用于测试“相等”
		
		警告：在编程的时候注意== (判断相等)和= (赋值)的使用，防止出现低级错误
		
			比较两个字符串是否相等应该使用库函数---strcmp，而不能使用==来判断！
			
	
	6、逻辑操作符
	  
		&&  逻辑与
		||  逻辑或

			1|2--->3
			1&2--->0
			1||2--->1
			1&&2--->1
			
			int c=a && b;
			如果a=0的话后边的表达式就不算了
			int c=a || b;
			如果a为真的话后面的表达式就不算了
		
		
	7、条件操作符(三目操作符)
	
		exp1 ? exp2 : exp3
			
			如果exp1为真则计算exp2；如果exp1为假则计算exp3!
			
	8、逗号表达式
	
		exp1, exp2, exp3, …expN
		
		逗号表达式，就是用逗号隔开的多个表达式。
		逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果
		如：
			if(a=b+1,c=a/2,d>0)//逗号表达式中的表达式都会计算，但是只有最后一个表达式(d>0)其判断作用
			
	9、下标引用、函数调用和结构成员
		
		例如:
			int main()
			{
				int arr[10]={1,2,3,4,5,6,7,8,9,10};
				printf("%d\n",arr[4]);//arr[4]中的[]就是下标引用操作符
									  //[]的操作数是两个:arr 和 4
				return 0;
			}
			
			int main()
			{
				int a=10;
				int b=20;
				//函数调用
				int ret=Add(a,b);// () - 函数调用操作符
				return 0;
			}
			
			struct Book
			{
				//结构体的成员（变量）
				char name[20];
				char id[20];
				int price;
			};

			int main()
			{
				struct Book book = { "C语言","c202210302052",80 };
				struct Book *pb=&book;
				printf("书名:%s\n", book.name);
				printf("书号:%s\n", book.id);
				printf("价格:%d\n", book.price);
				printf("书名:%s\n", (*pb).name);
				printf("书号:%s\n", (*pb).id);
				printf("价格:%d\n", (*pb).price);
				printf("书名:%s\n", pb->name);
				printf("书号:%s\n", pb->id);
				printf("价格:%d\n", pb->price);				
				return 0;
			}
			结构体指针.成员名
			结构体指针->成员名
		
	
	表达式求值
	
		表达式求值的顺序一部分是由操作符的优先级和结合性决定的。
		同样、有些表达式的操作数在求值的过程中可能需要转换为其他类型!
		
	隐式类型转换
		
		C的整型算术运算总是至少以缺省整型的精度来进行的。
		为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
		
		·整型提升的意义：
			
			表达式的整型运算在CPU的相应运算器件内执行，CPU内整型运算器（ALL）的操作符的字节长度一般就是
			int的字节长度，同时也是CPU的通用寄存器的长度。
			
			因此，即使两个char类型的相加，在CPU执行实际上也要先转换为CPU内整型操作符的标准长度。
			
			通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中
			可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换
			为int或者unsigned int,然后才能送入CPU去执行计算。
			 
			
		整形提升：整形提升是按照变量的数据类型的符号位来提升的
			
			//负数的整形提升
			char c1= -1;
			变量c1的二进制（补码）中只有8个比特位：
			11111111
			因为char是有符号的char
			所以整形提升的时候，高位补充符号位，即为1
			提升后的结果是：
			111111111111111111111111111111111
			
			//正数的整形提升
			char c2 = 1;
			变量c2的二进制（补码）中只有8个比特位：
			00000001
			因为char 为有符号的char
			所以整形提升的时候，高位补充符号位，即为0
			提升后的结果是：
			00000000000000000000000000000001
			
			//无符号的整形提升，高位补0
			
		
		例如：
			int main()
			{
				char a=3;//00000011
				char b=127;//01111111
				char c=a+b;
				//00000000000000000000000000000011
				//00000000000000000000000001111111
				//00000000000000000000000010000010
				//10000010
				//此时c为char类型，需要整形提升
				//11111111111111111111111110000010（补码）
				//10000000000000000000000001111110（原码）
				printf("%d\n",c);//结果是-126
				return 0;
			}
			
			int main()
			{
				char c=1;
				printf("%u\n",sizeof(c));//输出结果为1
				printf("%u\n",sizeof(+c));//输出结果为4
				printf("%u\n",sizeof(-c));//输出结果为4
				printf("%u\n",sizeof(!c));//在vs编译器上是1，但是在gcc上是4
				//%u是unsigned int 
				return 0;
			}

	算术转换
		如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则
		操作就无法进行，下面的层次体系称为寻常算术转换。

		long double
		double
		float
		unsigned long int
		long int 
		unsigned int
		int

		如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。

		警告：算术转换要合理，要不然会有一些潜在的问题。



	操作符的属性
		复杂表达式的求值有三个影响的因素

			1、操作符的优先级
			2、操作符的结合性
			3、是否控制求值顺序

		两个相邻的操作符先执行那个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

		操作符优先级

			注意：在多个表达式的运算时可能会出现没有唯一的计算路径(问题表达式)

			#include<stdio.h>
			int fun()
			{
				static int count = 1;//static 创建好后不会销毁
				return ++count;
			}

			int main()
			{
				int answer;
				answer = fun() - fun() * fun();
				printf("%d\n", answer);
				return 0;
			}
			//输出结果是-10
			这是一个问题代码！！！
				
五、指针
	
	
	1、指针是什么？
		在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（Points to）存在
		电脑储存器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，
		地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。
		
		
		·地址：
			比如：燕京理工学院静苑0区就是一个地址！
			
		总结：指针就是变量，用来存放地址的变量。（存放在指针中的值都被当作地址处理）。
			  指针是用来存放地址的，地址是唯一标识一块地址空间的。
			  指针的大小在32位平台是4个字节，在64位平台是8个字节
			  
	2、指针类型的意义
		<1>指针类型决定了：指针解引用的权限有多大
		<2>指针类型决定了，指针走一步，能走多远（步长）
			即：int指针加一，相当于加了4个字节
				char指针加一，相当于加了1个字节

	3、野指针

		野指针就是指针指向的位置是不可知的（随机的、不确定的、没有明确限制的）

		野指针成因
			<1>指针未初始化
			int mian()
			{
				//这里的p就是一个野指针
				int * p;//p就是一个局部的指针变量，局部变量不初始化的话，默认就是初始值
				*p = 10;//非法访问内存了
				return 0;			
			}

			<2>指针越界访问
			int main()
			{
				int arr[10] = {0};
				int * p = arr;//数组名代表数组首元素的地址
				int i = 0;
				for(i = 0;i <= 10;i++)
				{
					*p = i;
					p++;//arr数组只有10个元素，但是i<=10多了1个元素，此时指针越界访问！
				}
				return 0;
			}
			<3>指针指向的空间释放（简单解释）
			test()
			{
				int a=10;
				return &a;
			}
			int main()
			{
				int* p=test();
				printf("%p\n",p);
				*p = 30;
				printf("%p\n",p);
			}
			代码的输出结果为006FF854和006FF854
			说明：局部变量a是在函数test中定义的，当运行完test函数时局部变量a就已经还给了操作系统了，所以在main函数中无法改变a的值
				 此时指针变量的访问是非法的！


		#如何规避野指针
			1、指针初始化
			{
				两种初始化方法：
					<1>当不知道指针变量要初始化为什么时，就直接初始化为NULL
						int * p=NULL;
					<2>明确知道初始化的值
					   int a=10;
					   int * p1=&a
			}
			2、小心指针越界
			{
				注意：C语言本身是不会自己检查数组的越界行为的
			}
			3、指针指向空间释放及时置于NULL
			4、指针使用前检查有效性（检查是否为NULL） 
			{
				比如：
				int main()
				{
					int * p=NULL;
					if(p!=NULL)
					{
						*p=19;
					}
					return 0;
				}
			}
	4、指针运算

		<1>指针+-整数
			#define N_VALUES 5
			float values[N_VALUES];
			float *vp;
			//指针+-	整数；指针的关系运算
			for(vp=&values[0];vp<&values[N_VALUES];)
			{
				*vp++ = 0;
			}
		<2>指针-指针
			//指针-指针得到的是两个指针之间的元素个数
			前提：
				两个指针指向同一块空间

		<3>指针的关系运算

			for(vp = &values[N_VALUES-1];vp > &values[0];)
			{
				*--vp = 0;
			}

			代码简化，将代码修改如下:
			for(vp = &values[N_VALUES-1];vp >= &values[0];vp--)
			{
				*vp=0;
			}

			实际上在绝大部分的编译器上是可以顺利完成任务的。然而我们还是应该避免这样写，因为标准并不保证它可行

			标准规定：

				允许指向数组元素的指针和指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与
				指向第一个元素之前的那个内存位置的指针进行比较。
	5、指针和数组

		数组名是数组首元素的地址
		int main()
		{
			int arr[10]={1,2,3,4,5,6,7,8,9,10};
			int* p=arr;
			printf("%d\n",2[arr]);//输出为3
			printf("%d\n",arr[2]);//输出为3

			return 0;
		}
		其中：arr[2] <==> *(arr+2) <==> *(p+2) <==> *(2+p) <==> *(2+arr) == 2[arr]
			 2[arr] <==> *(2+arr)
			 编译器在运算的时候最终会将其转换为*(arr+2)
			 同样的也可以将arr[2]写成p[2]

	6、二级指针
		指针变量也是变量，有变量就有地址，而二级指针就是存放指针变量的地址的！
		例如:
		int main()
		{
			int a=10;
			int *pa=&a;//pa是一个指针变量，一级指针
			int **ppa=&pa;//ppa就是一个二级指针变量
			return 0;
		}

		这里：*pa == a
			 *ppa == pa 
			**ppa == a

		当然还有三级指针，多级指针；但是三级指针的使用频率是非常小的！

	7、指针数组
		存放指针的数组就是指针数组！
		int arr[10];// 存放整型的数组是整型数组
		char ch[20];// 存放字符串的数组是字符数组
		int *parr[10];//整型数组指针  	


六、结构体
	 1、结构体的声明
	 	·结构：结构就是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
	 	而数组是相同类型变量的集合!

	 	struct Stu
	 	{
	 		//成员变量：	
	 		char name[20];//名字
	 		int age[3];//年龄
	 		int ID[10];//学号
	 	};//可加入全局变量！
	 	注意分号(;)不能丢！
	 	/*
	 	struct Stu
	 	{
	 		char name[20];
	 		int agr[3];
	 		int ID[20];
	 	}s1,s2;//s1 s2就是全局变量！
	 	*/
	 	struct Stu 就是一个类型，就同int一样
	 	struct Stu s;//s就是根据 struct Stu 这个类型创建的一个的对象
	 	例如：
		#include<stdio.h>

	 	struct Stu
	 	{
	 		char name[20];
	 		int age;
	 		int ID[10];
	 	};

	 	int main()
	 	{
	 		struct Stu s = {"tian",19,2020};
	 		return 0;
	 	}


	 	结构的成员可以是标量、数组、指针甚至是结构体！

	 2、结构体的访问
	 	结构体变量访问成员结构变量的成员是通过操作符（.）访问的。点操作符接受两个操作数。
	 	例如：

	 	struct B
	 	{
	 		int ID;
	 		char address[20];
	 	}
	 	struct Stu
	 	{
	 		char name[10];
	 		int age;
	 		struct B date;
	 	};
	 	int main()
	 	{
	 		struct Stu s = {"tian",19,{2020,"China"}};
	 		printf("%s\n",s.date.address);
	 		return 0;
	 	}
	 补充：
	 	struct Stu *ps = &s;
	 	printf("%s\n",(*ps).date.address);
	 	//或者：
	 	printf("%s\n",ps->date.address);
	 	此时的 ps->date 就相当于 (*ps).date//注意只有指针访问的时候采用->

	 3、结构体传参
	 	struct B
	 	{
	 		int ID;
	 		char address[20];
	 	}
	 	struct Stu
	 	{
	 		char name[10];
	 		int age;
	 		struct B date;
	 	};
	 	void print1(struct Stu t) 
	 	{
	 		printf("%s %d %d %s\n",t.name,t.age,t.date.ID,t.date.address);
	 	}
	 	void print2(struct Stu *ps)
	 	{
	 		printf("%s %d %d %s\n",ps->name,ps->age,ps->date.ID,ps->date.address);
	 	}
	 	int main()
	 	{
	 		struct Stu s = {"tian",19,{2020,"China"}};
	 		print1(s);//传值调用
	 		print2(&s);//传址调用
	 		return 0;
	 	}
	 	这里的print1要比print2要好！因为：
	 		函数传参的时候，参数是需要压线的。如果传递一个结构体对象的时候，结构体过大，
	 		参数压栈的系统开销比较大，所以会导致性能的下降。
	 	结论：
	 		结构体传参的时候，要传结构体的地址!

	 	栈，是一种数据结构，也叫堆栈！
	 	-->先进的后出，后进的先出
	 	将数据放到栈中的操作叫做压栈；
	 	从栈中删除数据元素的操作叫做出栈；

	 注意：每一个函数的调用都会在栈区上开辟一块空间！
	 	   参数传参的操作也叫压栈操作！
	 	

	 	局部变量是放到栈区上的：
	 	*栈区内存的使用习惯是：先使用高地址空间，在使用低地址的空间！


	 实例：模拟strcpy函数
	 	#include<stdio.h>
	 	#include<assert.h>

	 	void my_strcpy(char* arr1,char* arr2);//最初的模拟strcpy函数
	 	void my_strcpy1(char* arr1,char* arr2);//改进的模拟strcpy函数
	 	int main()
	 	{
	 		char arr1[20] = "*************";
	 		char arr2[] = "hello";
	 		my_strcpy(arr1,arr2);//调用函数
	 		printf("%s\n",arr1);
	 		return 0;
	 	}
	 	void my_strcpy(char* arr1,char* arr2)
	 	{
	 		while(*arr2 != '\0')
	 		{
	 			*arr1 = *arr2;
	 			arr1++;
	 			arr2++;
	 		}
	 	}
	 	void my_strcpy1(char* arr1,char* arr2)
	 	{
	 		assert(arr1 != NULL);//断言！
	 		assert(arr2 != NULL);//断言！
	 		while(*arr1++ = *arr2++)
	 		{

	 		}
	 	}

	 而在string.h这个头文件中包含的strcpy函数的原型是：
	 char * strcpy ( char * destination, const char * source );
	 其中在参数source前加上了const关键字！


	 	const 关键字
	 		：const修饰变量，这个变量就是常变量（不能被修改，但是本身还是变量）
